<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>新富STREET謹製ポケモンバトル</title>
  <style>
    /* Basic reset and layout */
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP",sans-serif;margin:0;background:#0b1220;color:#eef2ff}
    .container{max-width:1100px;margin:20px auto;padding:18px;background:linear-gradient(180deg,#081023 0%, #0c1628 100%);border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,.6)}
    header{display:flex;justify-content:space-between;align-items:center}
    h1{font-size:20px;margin:0}
    .cols{display:grid;grid-template-columns:320px 1fr;gap:16px;margin-top:16px}
    .card{background:linear-gradient(180deg,#0f2740, #072033);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,.04)}
    .small{font-size:13px;color:#b9d1ff}
    .select-list{display:flex;flex-direction:column;gap:6px}
    button,select,input{font-size:14px}
    .btn{background:#2b6bf6;color:white;padding:8px 10px;border-radius:8px;border:none;cursor:pointer}
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,.06)}
    .flex{display:flex;gap:8px;align-items:center}
    .battle-area{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .poke-box{background:linear-gradient(180deg,#072a3e,#05232f);padding:10px;border-radius:8px;min-height:120px}
    .hpbar{height:12px;background:rgba(255,255,255,.06);border-radius:8px;overflow:hidden}
    .hpbar > i{display:block;height:100%;background:linear-gradient(90deg,#51e06b,#2bd06b);width:100%}
    .moves{display:grid;grid-template-columns:repeat(2,1fr);gap:6px;margin-top:8px}
    .move{background:#0b2340;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,.03);cursor:pointer}
    .message-log{height:140px;overflow:hidden;padding:6px;border-radius:6px;background:rgba(0,0,0,.12);font-size:13px}
    .message-line{margin-bottom:6px}
    .room-controls{display:flex;gap:8px;align-items:center}
    .pokemon-list{display:flex;gap:8px;flex-wrap:wrap}
    .pokemon-card{padding:8px;border-radius:8px;background:rgba(255,255,255,.03);cursor:pointer}
    .selected{outline:2px solid #59d3ff}
    .stats-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:6px}
    .footer{margin-top:12px;color:#9fb6ff;font-size:13px}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>新富STREET謹製ポケモンバトル（簡易）</h1>
      <div class="small">オンライン同期：Firebase Realtime Database（設定を下に入力）</div>
    </header>

    <div class="cols">
      <div class="card">
        <div><strong>プレイヤー設定</strong></div>
        <div style="margin-top:8px" class="small">プレイヤー名</div>
        <input id="playerName" placeholder="名前を入力" />

        <div style="margin-top:10px" class="small">Firebase設定（自分のプロジェクトのconfigに置き換えてください）</div>
        <textarea id="firebaseConfig" style="width:100%;height:90px;font-size:12px">{
  "apiKey": "YOUR_API_KEY",
  "authDomain": "YOUR_AUTH_DOMAIN",
  "databaseURL": "YOUR_DATABASE_URL",
  "projectId": "YOUR_PROJECT_ID",
  "storageBucket": "",
  "messagingSenderId": "",
  "appId": ""
}</textarea>

        <div style="margin-top:8px" class="small">モード</div>
        <div class="flex">
          <button class="btn" id="btnLocal">CPU対戦（オフライン）</button>
          <button class="btn ghost" id="btnHost">部屋を作る</button>
          <button class="btn ghost" id="btnJoin">部屋に入る</button>
        </div>
        <div style="margin-top:8px" class="small">部屋パスワード（作成時表示／参加時入力）</div>
        <input id="roomPwd" placeholder="6文字のパスワード" />

        <hr style="margin:10px 0;border:none;border-top:1px solid rgba(255,255,255,.04)" />

        <div><strong>使用できるポケモン（6体から3体選択）</strong></div>
        <div class="pokemon-list" id="pokeSelector"></div>
        <div class="small" style="margin-top:8px">選択後、各ポケモンに4つの技を割り当てます。</div>

        <div style="margin-top:8px" class="flex">
          <button class="btn" id="btnAssign">技割当フェーズへ進む</button>
        </div>

      </div>

      <div class="card">
        <div class="battle-area">
          <div>
            <div class="flex" style="justify-content:space-between;align-items:flex-start">
              <div>
                <div id="myName" style="font-weight:700">—</div>
                <div class="small">残り: <span id="myLeft">---</span></div>
              </div>
              <div style="text-align:right">
                <div id="opName" style="font-weight:700">—</div>
                <div class="small">残り: <span id="opLeft">---</span></div>
              </div>
            </div>

            <div style="display:grid;grid-template-columns:1fr 1fr;margin-top:12px;gap:10px">
              <div class="poke-box">
                <div id="myPokeName">---</div>
                <div class="small">状態: <span id="myStatus">---</span></div>
                <div style="margin-top:6px">HP <span id="myHPtext">0/0</span></div>
                <div class="hpbar" style="margin-top:6px"><i id="myHPbar" style="width:100%"></i></div>
                <div class="small" style="margin-top:6px">能力変化</div>
                <div id="myStages" class="small">---</div>
              </div>

              <div class="poke-box">
                <div id="opPokeName">---</div>
                <div class="small">状態: <span id="opStatus">---</span></div>
                <div style="margin-top:6px">HP <span id="opHPtext">0/0</span></div>
                <div class="hpbar" style="margin-top:6px"><i id="opHPbar" style="width:100%"></i></div>
                <div class="small" style="margin-top:6px">能力変化</div>
                <div id="opStages" class="small">---</div>
              </div>
            </div>

            <div style="margin-top:12px">
              <div class="small">天気: <span id="weatherText">なし</span></div>
            </div>

            <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
              <div style="flex:1">
                <div class="small">技選択</div>
                <div class="moves" id="movesArea"></div>
              </div>

              <div style="width:40%">
                <div class="small">バトルメッセージ</div>
                <div class="message-log" id="messages"></div>
              </div>
            </div>

            <div style="margin-top:10px">
              <div class="small">手持ちポケモン</div>
              <div id="handList" class="flex"></div>
            </div>

          </div>

        </div>
        <div class="footer">注: Firebaseの設定を入れて部屋を作ると別デバイスと同期して遊べます。CPU戦は端末単独で動きます。</div>
      </div>
    </div>
  </div>

  <script>
  // --- Data: Pokémon, abilities, moves, type chart (simplified but faithful) ---
  const POKEMON = {
    "そうじ":{types:["むし","じめん"], ability:"カブトアーマー", hp:65,atk:55,def:58,spa:75,spd:60,spe:90},
    "しょうき":{types:["ひこう","エスパー"], ability:"たんじゅん", hp:95,atk:95,def:95,spa:105,spd:100,spe:80},
    "たかす":{types:["みず","どく"], ability:"ひとでなし", hp:78,atk:100,def:85,spa:93,spd:90,spe:85},
    "じゅん":{types:["ノーマル","フェアリー"], ability:"きょううん", hp:108,atk:120,def:110,spa:80,spd:95,spe:115},
    "たけしげ":{types:["でんき","いわ"], ability:"てんねん", hp:90,atk:135,def:105,spa:30,spd:75,spe:70},
    "なつうみ":{types:["あく","エスパー"], ability:"ぜったいねむり", hp:70,atk:60,def:65,spa:113,spd:70,spe:108}
  };

  // Moves: we'll include many from the provided list but only set power/category for common ones.
  const MOVES = {
    "すてみタックル":{type:"ノーマル",category:"physical",power:120,acc:100,pp:10,recoil:1/3},
    "ハイパーボイス":{type:"ノーマル",category:"special",power:90,acc:100,pp:10},
    "じこさいせい":{type:"ノーマル",category:"status",pp:10,healPct:0.5},
    "ねごと":{type:"ノーマル",category:"status" ,pp:10},
    "ギガインパクト":{type:"ノーマル",category:"physical",power:150,acc:90,pp:5,recharge:true},
    "ハイドロポンプ":{type:"みず",category:"special",power:110,acc:80,pp:5},
    "なみのり":{type:"みず",category:"special",power:90,acc:100,pp:15},
    "クイックターン":{type:"みず",category:"physical",power:60,acc:100,pp:20,switchBack:true},
    "じゅうでん":{type:"でんき",category:"status",pp:10,boost:{spa:1}},
    "10万ボルト":{type:"でんき",category:"special",power:90,acc:100,pp:10,par:0.1},
    "エアスラッシュ":{type:"ひこう",category:"special",power:75,acc:95,flinch:0.3},
    "ブレイブバード":{type:"ひこう",category:"physical",power:120,acc:100,recoil:1/3},
    "サイコキネシス":{type:"エスパー",category:"special",power:90,acc:100,pp:10},
    "ねむる":{type:"エスパー",category:"status",pp:10,restore:"sleep"},
    "むしのさざめき":{type:"むし",category:"special",power:90,acc:100,pp:10},
    "メガホーン":{type:"むし",category:"physical",power:120,acc:85,pp:10},
    "がんせきふうじ":{type:"いわ",category:"physical",power:60,acc:95,pp:15,accDown:1},
    "じゃれつく":{type:"フェアリー",category:"physical",power:90,acc:100,pp:20},
    "すてぜりふ":{type:"あく",category:"status",pp:15,boost:{atk:1,spa:1}},
    "ふいうち":{type:"あく",category:"physical",power:70,acc:100,pp:15,priority:1}
  };

  // Type chart minimal for types present. multiplier: 2,0.5,0
  const TYPE_CHART = {
    "ノーマル":{"いわ":0.5,"ゴースト":0},
    "みず":{},
    "でんき":{"じめん":0},
    "くさ":{"ほのお":0.5,"みず":2},
    "どく":{},
    "じめん":{"でんき":2,"ひこう":0},
    "ひこう":{"くさ":2,"でんき":0.5},
    "エスパー":{"あく":0, "どく":0.5},
    "むし":{"エスパー":2,"あく":2,"フェアリー":0.5},
    "いわ":{"むし":2,"ひこう":2},
    "あく":{"エスパー":2,"ゴースト":2},
    "フェアリー":{"あく":2}
  };

  // Utility functions
  function typeMultiplier(moveType, defenderTypes){
    let m=1;
    defenderTypes.forEach(t=>{
      const tab = TYPE_CHART[moveType]||{};
      if(tab[t]!==undefined) m*=tab[t];
    });
    return m;
  }

  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

  // --- Game State ---
  const GAME = {
    playerName: '',
    opponentName: '',
    myTeam: [], // {name, moves:[..],curHP,maxHP,stages:{atk:0,...},status:null,ability}
    opTeam: [],
    turnOwner:null,
    weather:null,
    messages:[],
    isOnline:false,
    firebase:null,
    db:null,
    roomRef:null
  };

  // UI wiring
  const pokeSelector = document.getElementById('pokeSelector');
  const btnAssign = document.getElementById('btnAssign');
  const btnLocal = document.getElementById('btnLocal');
  const btnHost = document.getElementById('btnHost');
  const btnJoin = document.getElementById('btnJoin');
  const playerNameInput = document.getElementById('playerName');
  const roomPwdInput = document.getElementById('roomPwd');
  const firebaseConfigArea = document.getElementById('firebaseConfig');

  const myNameEl = document.getElementById('myName');
  const opNameEl = document.getElementById('opName');
  const myLeft = document.getElementById('myLeft');
  const opLeft = document.getElementById('opLeft');
  const myPokeName = document.getElementById('myPokeName');
  const opPokeName = document.getElementById('opPokeName');
  const myHPtext = document.getElementById('myHPtext');
  const opHPtext = document.getElementById('opHPtext');
  const myHPbar = document.getElementById('myHPbar');
  const opHPbar = document.getElementById('opHPbar');
  const movesArea = document.getElementById('movesArea');
  const messagesEl = document.getElementById('messages');
  const myStatus = document.getElementById('myStatus');
  const opStatus = document.getElementById('opStatus');
  const myStages = document.getElementById('myStages');
  const opStages = document.getElementById('opStages');
  const handList = document.getElementById('handList');
  const weatherText = document.getElementById('weatherText');

  // initialize selector
  Object.keys(POKEMON).forEach(name=>{
    const el = document.createElement('div');
    el.className='pokemon-card';
    el.textContent = name + ' ('+POKEMON[name].types.join('/')+')';
    el.dataset.name = name;
    el.addEventListener('click',()=>togglePick(el));
    pokeSelector.appendChild(el);
  });

  function togglePick(el){
    const name = el.dataset.name;
    const picked = GAME._picked||[];
    if(picked.includes(name)){
      GAME._picked = picked.filter(p=>p!==name);
      el.classList.remove('selected');
    } else {
      if(picked.length>=3) return alert('3体までです');
      GAME._picked = [...picked,name];
      el.classList.add('selected');
    }
  }

  btnAssign.addEventListener('click',()=>{
    const picked = GAME._picked||[];
    if(picked.length!==3) return alert('まず3体選んでください');
    // move assignment: simple prompt flow
    GAME.myTeam = picked.map(n=>createTeamMon(n));
    assignMovesToTeam(GAME.myTeam).then(()=>{
      alert('技割当完了。対戦を開始してください（CPUか部屋作成/参加）。');
      renderHand();
    });
  });

  btnLocal.addEventListener('click',()=>{
    if(!playerNameInput.value) return alert('名前を入れてください');
    GAME.playerName = playerNameInput.value;
    GAME.opponentName = 'CPU';
    GAME.isOnline = false;
    // fill opponent team randomly
    GAME.opTeam = randomCpuTeam();
    startBattle();
  });

  btnHost.addEventListener('click',()=>{
    // initialize firebase and create room
    if(!playerNameInput.value) return alert('名前を入れてください');
    const cfg = parseConfig(firebaseConfigArea.value);
    if(!cfg) return alert('Firebase設定を正しく入力してください');
    initFirebase(cfg).then(()=>{
      createRoom(roomPwdInput.value || generatePwd()).then(refKey=>{
        alert('部屋作成しました。パスワード: '+roomPwdInput.value || refKey + '\n別デバイスで参加してください');
        GAME.playerName = playerNameInput.value;
        GAME.isOnline = true;
        // host waits for challenger to join; our team must be assigned first
        if(!GAME.myTeam.length) return alert('まず3体選んで技を割り当ててください');
        // push initial state
        pushStateToRoom();
        listenRoom();
      }).catch(e=>alert('作成失敗: '+e.message));
    });
  });

  btnJoin.addEventListener('click',()=>{
    const cfg = parseConfig(firebaseConfigArea.value);
    if(!cfg) return alert('Firebase設定を正しく入力してください');
    initFirebase(cfg).then(()=>{
      const pwd = roomPwdInput.value;
      if(!pwd) return alert('パスワードを入れてください');
      joinRoom(pwd).then(ok=>{
        GAME.playerName = playerNameInput.value || 'Player';
        GAME.isOnline = true;
        listenRoom();
      }).catch(e=>alert('参加失敗: '+e.message));
    });
  });

  // create team member from base
  function createTeamMon(name){
    const base = POKEMON[name];
    const maxHP = base.hp;
    return {name,types:base.types.slice(),ability:base.ability,maxHP,curHP:maxHP,moves:[],stages:{atk:0,def:0,spa:0,spd:0,spe:0},status:null, asleepBehind:false};
  }

  function assignMovesToTeam(team){
    // sequential prompt: choose 4 moves from MOVES keys
    return new Promise(resolve=>{
      // simple UI: prompt-based for now
      (async ()=>{
        for(let mon of team){
          const keys = Object.keys(MOVES);
          const selected = [];
          while(selected.length<4){
            const choice = prompt(mon.name+' に覚えさせる技を選んでください（残り '+(4-selected.length)+'）\n候補: '+keys.join(', '));
            if(!choice) return alert('技割当中断');
            if(!MOVES[choice]){alert('存在しない技'); continue}
            if(selected.includes(choice)) {alert('既に選択済み'); continue}
            selected.push(choice);
          }
          mon.moves = selected.map(m=>({id:m,offPP:MOVES[m].pp||10}));
        }
        resolve();
      })();
    });
  }

  function randomCpuTeam(){
    const names = Object.keys(POKEMON).filter(n=>!GAME.myTeam.map(m=>m.name).includes(n));
    const pick = names.sort(()=>0.5-Math.random()).slice(0,3);
    return pick.map(n=>{
      const m = createTeamMon(n);
      // choose random 4 moves for CPU from MOVES
      const keys = Object.keys(MOVES).sort(()=>0.5-Math.random()).slice(0,4);
      m.moves = keys.map(k=>({id:k,offPP:MOVES[k].pp||10}));
      return m;
    });
  }

  // Rendering helpers
  function renderHand(){
    myNameEl.textContent = GAME.playerName;
    opNameEl.textContent = GAME.opponentName;
    myLeft.textContent = remainingCount(GAME.myTeam);
    opLeft.textContent = remainingCount(GAME.opTeam);
    renderActive();
    handList.innerHTML='';
    GAME.myTeam.forEach((m,i)=>{
      const d = document.createElement('div');
      d.className='pokemon-card';
      d.textContent = m.name + ' ' + Math.max(0,m.curHP)+'/'+m.maxHP;
      d.addEventListener('click',()=>switchTo(i));
      handList.appendChild(d);
    });
    weatherText.textContent = GAME.weather||'なし';
  }

  function renderActive(){
    const my = GAME.myTeam[0];
    const op = GAME.opTeam[0];
    if(my){
      myPokeName.textContent = my.name + '（' + GAME.playerName + '）';
      myHPtext.textContent = my.curHP + '/' + my.maxHP;
      myHPbar.style.width = (my.curHP/my.maxHP*100)+'%';
      myStatus.textContent = my.status||'—';
      myStages.textContent = formatStages(my.stages);
      movesArea.innerHTML='';
      my.moves.forEach((mv,idx)=>{
        const el = document.createElement('div');
        el.className='move';
        el.textContent = mv.id + ' (' + (MOVES[mv.id].pp||'—') + ')';
        el.addEventListener('click',()=>chooseMove(idx));
        movesArea.appendChild(el);
      });
    }
    if(op){
      opPokeName.textContent = op.name + '（' + GAME.opponentName + '）';
      opHPtext.textContent = op.curHP + '/' + op.maxHP;
      opHPbar.style.width = (op.curHP/op.maxHP*100)+'%';
      opStatus.textContent = op.status||'—';
      opStages.textContent = formatStages(op.stages);
    }
  }

  function formatStages(st){
    return `こうげき:${st.atk>=0?'+':''}${st.atk} とくこう:${st.spa>=0?'+':''}${st.spa} ぼうぎょ:${st.def>=0?'+':''}${st.def}`;
  }

  function remainingCount(team){
    return team.filter(m=>m.curHP>0).length;
  }

  // Messages queue with timed display
  function pushMessage(msg){
    GAME.messages.push(msg);
    // display with short intervals
    showMessages();
  }
  let msgTimer=null;
  function showMessages(){
    if(msgTimer) return; // already playing
    const lines = GAME.messages.slice();
    messagesEl.innerHTML='';
    let i=0;
    msgTimer = setInterval(()=>{
      if(i>=lines.length){ clearInterval(msgTimer); msgTimer=null; GAME.messages=[]; return; }
      const d = document.createElement('div'); d.className='message-line'; d.textContent = lines[i]; messagesEl.prepend(d);
      i++;
    },500);
  }

  // Choosing move
  function chooseMove(idx){
    // user selects a move; compute action for both sides (if CPU online, wait for opponent...)
    const action = {type:'move',who:'player',moveIdx:idx};
    if(GAME.isOnline){
      // update room with chosen action
      GAME.pendingAction = action;
      pushStateToRoom();
    } else {
      // CPU picks
      const cpuAction = cpuChooseMove();
      resolveTurn(action,cpuAction);
    }
  }

  function cpuChooseMove(){
    // simple: random available move
    const mvlist = GAME.opTeam[0].moves;
    const idx = Math.floor(Math.random()*mvlist.length);
    return {type:'move',who:'cpu',moveIdx:idx};
  }

  function switchTo(index){
    if(index===0) return; // already active
    // ensure target alive
    if(GAME.myTeam[index].curHP<=0) return alert('そのポケモンは戦闘不能です');
    // switch immediately when not online
    if(GAME.isOnline){ GAME.pendingAction = {type:'switch',who:'player',to:index}; pushStateToRoom(); }
    else { const cpuAct = cpuChooseMove(); resolveTurn({type:'switch',who:'player',to:index}, cpuAct); }
  }

  // Core turn resolution simplified but captures speed, priority, abilities
  function resolveTurn(actA, actB){
    // assemble actions in order by priority and speed
    const a = actA.who==='player'?{actor:'player',action:actA,mon:GAME.myTeam[0]}:{actor:'cpu',action:actA,mon:GAME.opTeam[0]};
    const b = actB.who==='cpu'?{actor:'cpu',action:actB,mon:GAME.opTeam[0]}:{actor:'player',action:actB,mon:GAME.myTeam[0]};

    // compute effective priority
    const acts = [a,b];
    acts.sort((x,y)=>{
      const px = x.action.moveIdx!==undefined? (MOVES[x.mon.moves[x.action.moveIdx].id].priority||0) : 0;
      const py = y.action.moveIdx!==undefined? (MOVES[y.mon.moves[y.action.moveIdx].id].priority||0) : 0;
      if(px!==py) return py-px; // higher priority first
      // then speed
      const sx = effectiveStat(x.mon,'spe');
      const sy = effectiveStat(y.mon,'spe');
      return sy-sx; // faster first
    });

    // execute in order
    (async ()=>{
      for(const turn of acts){
        if(checkBattleEnd()) return;
        const act = turn.action;
        if(act.type==='move'){
          // verify user/mon is alive
          if(turn.mon.curHP<=0){ pushMessage(`${turn.mon.name}（${turn.actor==='player'?GAME.playerName:GAME.opponentName}）は戦闘不能で行動できない！`); continue; }
          const mv = turn.mon.moves[act.moveIdx];
          await applyMove(turn, mv);
          // check faint and auto-switch for CPU
          autoSwitchIfNeeded();
          renderHand();
        } else if(act.type==='switch'){
          if(turn.actor==='player'){
            // bring chosen mon to front
            const idx = act.to;
            const mon = GAME.myTeam.splice(idx,1)[0];
            GAME.myTeam.unshift(mon);
            pushMessage(`${mon.name}（${GAME.playerName}）をくりだした！`);
          } else {
            const idx = act.to;
            const mon = GAME.opTeam.splice(idx,1)[0];
            GAME.opTeam.unshift(mon);
            pushMessage(`${mon.name}（${GAME.opponentName}）をくりだした！`);
          }
        }
        await sleep(300);
      }
      // end of turn: apply residuals (poison etc)
      applyEndOfTurn();
      renderHand();
      checkBattleEnd();
    })();
  }

  async function applyMove(turn, mvObj){
    const move = MOVES[mvObj.id];
    const user = turn.mon;
    const target = (turn.actor==='player')? GAME.opTeam[0]: GAME.myTeam[0];
    const userName = turn.actor==='player'?GAME.playerName:GAME.opponentName;
    const targetName = turn.actor==='player'?GAME.opponentName:GAME.playerName;

    pushMessage(`${user.name}（${userName}）は ${mvObj.id} を使った！`);
    await sleep(400);

    // Status moves
    if(move.category==='status'){
      if(move.healPct){
        const heal = Math.floor(user.maxHP * move.healPct);
        user.curHP = clamp(user.curHP+heal,0,user.maxHP);
        pushMessage(`${user.name}（${userName}）は ${heal} 回復した！`);
      }
      if(move.boost){
        Object.keys(move.boost).forEach(k=>{ user.stages[k] = clamp(user.stages[k]+move.boost[k],-6,6); });
        pushMessage(`${user.name}（${userName}）の能力が上がった！`);
      }
      if(move.restore==='sleep'){
        user.status = 'ねむり';
        pushMessage(`${user.name}（${userName}）は眠った！`);
      }
      return;
    }

    // accuracy check
    const acc = move.acc||100;
    if(Math.random()*100 > acc){ pushMessage('しかし、外れた！'); return; }

    // critical check: simple rate
    let crit = Math.random() < 0.0625;
    // ability modifications for crit etc
    if(user.ability==='きょううん' && Math.random()<0.12) crit=true;
    if(target.ability==='カブトアーマー') crit=false; // cannot be crit
    // special 'ひとでなし' guarantees crit when target poisoned
    if(user.ability==='ひとでなし' && target.status==='どく') crit=true;

    // damage calc (simplified gen formula)
    const level=50;
    const power = move.power||0;
    const A = move.category==='physical'? effectiveStat(user,'atk') : effectiveStat(user,'spa');
    const D = move.category==='physical'? effectiveStat(target,'def') : effectiveStat(target,'spd');
    let base = Math.floor(Math.floor((Math.floor((2*level/5)+2)*power*A)/D)/50)+2;
    // modifiers: STAB
    const moveType = move.type;
    const stab = user.types.includes(moveType)?1.5:1;
    const tmult = typeMultiplier(moveType, target.types)||1;
    const rand = 0.85 + Math.random()*0.15;
    const critMult = crit?1.5:1;
    let dmg = Math.floor(base * stab * tmult * rand * critMult);
    if(dmg<1) dmg=1;
    target.curHP = clamp(target.curHP - dmg, 0, target.maxHP);

    let sfx = '';
    if(crit) sfx += ' 急所に当たった！';
    if(tmult>=2) sfx += ' 効果は抜群だ！';
    if(tmult>0 && tmult<1) sfx += ' 効果はいまひとつだ。';
    pushMessage(`${target.name}（${targetName}）に ${dmg} のダメージ！` + sfx);

    // recoil
    if(move.recoil){
      const rec = Math.floor(dmg * move.recoil);
      user.curHP = clamp(user.curHP - rec,0,user.maxHP);
      pushMessage(`${user.name}（${userName}）は反動で ${rec} のダメージ！`);
    }

    // flinch
    if(move.flinch && Math.random() < move.flinch){ target.fluffed = true; }

    // paralyze chance
    if(move.par && Math.random()<move.par){ target.status = 'まひ'; pushMessage(`${target.name}（${targetName}）はまひした！`); }

    // decrease accuracy or other side effects omitted for brevity
  }

  function effectiveStat(mon,stat){
    // convert stat name to attribute
    const map = {atk:'atk',def:'def',spa:'spa',spd:'spd',spe:'spe'};
    const base = POKEMON[mon.name][map[stat]];
    const stage = mon.stages[map[stat]]||0;
    const mult = stage>=0? ( (2+stage)/2 ) : (2/(2-Math.abs(stage)) );
    return Math.max(1, Math.floor(base * mult));
  }

  function autoSwitchIfNeeded(){
    // if front fainted, bring next available
    if(GAME.opTeam[0].curHP<=0){
      pushMessage(`${GAME.opTeam[0].name}（${GAME.opponentName}）は倒れた！`);
      const idx = GAME.opTeam.findIndex(m=>m.curHP>0);
      if(idx>=0){ const mon = GAME.opTeam.splice(idx,1)[0]; GAME.opTeam.unshift(mon); pushMessage(`${mon.name}（${GAME.opponentName}）を自動でくりだした！`); }
    }
    if(GAME.myTeam[0].curHP<=0){
      pushMessage(`${GAME.myTeam[0].name}（${GAME.playerName}）は倒れた！`);
      const idx = GAME.myTeam.findIndex(m=>m.curHP>0);
      if(idx>=0){ const mon = GAME.myTeam.splice(idx,1)[0]; GAME.myTeam.unshift(mon); pushMessage(`${mon.name}（${GAME.playerName}）を自動でくりだした！`); }
    }
  }

  function applyEndOfTurn(){
    // poison, etc placeholder
    [GAME.myTeam[0], GAME.opTeam[0]].forEach(mon=>{
      if(!mon) return;
      if(mon.status==='どく'){
        const dmg = Math.floor(mon.maxHP/8);
        mon.curHP = clamp(mon.curHP - dmg,0,mon.maxHP);
        pushMessage(`${mon.name}は毒で ${dmg} ダメージを受けた！`);
      }
    });
  }

  function checkBattleEnd(){
    const myLeftCnt = remainingCount(GAME.myTeam);
    const opLeftCnt = remainingCount(GAME.opTeam);
    myLeft.textContent = myLeftCnt;
    opLeft.textContent = opLeftCnt;
    if(myLeftCnt===0 || opLeftCnt===0){
      const win = opLeftCnt===0;
      pushMessage(win? 'あなたの勝ち！':'あなたの負け...');
      return true;
    }
    return false;
  }

  // Simple helpers
  function sleep(ms){return new Promise(r=>setTimeout(r,ms));}

  function parseConfig(txt){
    try{ return JSON.parse(txt); }catch(e){return null}
  }

  function generatePwd(){ return Math.random().toString(36).slice(2,8).toUpperCase(); }

  // --- Firebase integration (Realtime DB) ---
  async function initFirebase(cfg){
    // load firebase SDK dynamically
    if(window.firebase && window.firebase.apps && window.firebase.apps.length){
      // already
    } else {
      await new Promise((res,rej)=>{
        const s=document.createElement('script'); s.src='https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js'; s.onload=res; s.onerror=rej; document.head.appendChild(s);
      });
      await new Promise((res,rej)=>{
        const s=document.createElement('script'); s.src='https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js'; s.onload=res; s.onerror=rej; document.head.appendChild(s);
      });
    }
    firebase.initializeApp(cfg);
    GAME.firebase = firebase; GAME.db = firebase.database();
  }

  async function createRoom(pwd){
    const key = pwd || generatePwd();
    const room = {host:GAME.playerName,players:{host:{name:GAME.playerName}},state:{}};
    await GAME.db.ref('rooms/'+key).set(room);
    GAME.roomRef = 'rooms/'+key;
    return key;
  }

  async function joinRoom(pwd){
    const snap = await GAME.db.ref('rooms/'+pwd).get();
    if(!snap.exists()) throw new Error('見つかりません');
    const room = snap.val();
    // register as challenger
    await GAME.db.ref('rooms/'+pwd+'/players/challenger').set({name:GAME.playerName});
    GAME.roomRef = 'rooms/'+pwd;
    return true;
  }

  function pushStateToRoom(){
    if(!GAME.roomRef) return;
    const payload = {playerName:GAME.playerName,myTeam:GAME.myTeam,opTeam:GAME.opTeam,weather:GAME.weather,pendingAction:GAME.pendingAction||null};
    GAME.db.ref(GAME.roomRef+'/state').set(payload);
  }

  function listenRoom(){
    if(!GAME.roomRef) return;
    GAME.db.ref(GAME.roomRef+'/state').on('value',snap=>{
      const val = snap.val();
      if(!val) return;
      // simple sync: if we are challenger, opponent data becomes host
      if(val.playerName && val.playerName!==GAME.playerName){
        GAME.opponentName = val.playerName; // host's name
      }
      // if challenger and host both pushed teams, start battle
      if(!GAME.myTeam.length && val.opTeam && val.myTeam){
        // choose where to put our team
      }
      // handle pending actions
      if(val.pendingAction){
        // when both actions present, resolve
        if(GAME._remoteAction && GAME._remoteAction.actor!==val.pendingAction.who){
          // both present -> resolve
          const local = GAME.pendingAction || null;
          const remote = val.pendingAction;
          if(local){
            // map to internal action objects
            const a = local;
            const b = remote;
            resolveTurn(a,b);
            GAME.db.ref(GAME.roomRef+'/state/pendingAction').remove();
            GAME.pendingAction = null;
            GAME._remoteAction = null;
          } else {
            // store remote
            GAME._remoteAction = val.pendingAction;
          }
        } else {
          GAME._remoteAction = val.pendingAction;
        }
      }
    });
  }

  // initial render
  renderHand();

  </script>
</body>
</html>
